package main

import (
	"fmt"
	"os"
	"strings"
)

func buildSandboxProfile(context *Context) {
	profile := "; Generated by cli tool sb\n"
	profile += readBaseProfile() + "\n"
	profile += fmt.Sprintf(`;;; Basics
	; Allow running the target and node binary
	(allow process-exec file-read* (literal "%s"))
	(allow file-read* (literal "%s"))`, context.Config.BinaryPath, context.Config.BinaryDirPath)
	profile += fmt.Sprintf(`
	(allow file-read*
%v
	)`, buildLiteralFolders(context.Paths.WorkingDir))
	profile += netIn(context.Config.SbConfig, profile)
	profile += netOut(context.Config.SbConfig, profile)
	fmt.Println(profile)
}

func netOut(config *SbConfig, profile string) string {
	if config.NetworkOutbound {
		profile += `
	; allow-net-outbound: enabled
	(allow network-inbound
	  (local tcp)
	  (local udp)
	)
	(allow network-outbound)
	(allow network-bind)
	(allow system-socket)
	`
	}
	return profile
}

func netIn(config *SbConfig, profile string) string {
	if config.NetworkInbound {
		profile += `
	; allow-net-inbound: enabled
	(allow network-bind network-inbound
	  (local tcp)
	  (local udp))
	(allow system-socket)
	(allow file-read* (literal "/private/var/run/resolv.conf"))
	`
	}
	return profile
}

func buildLiteralFolders(path string) string {
	allPaths := ""
	currentPath := ""
	paths := strings.Split(path, "/")
	for _, singlePath := range paths[1:] {
		currentPath += "/" + singlePath
		allPaths += "		(literal \"" + currentPath + "\")\n"
	}
	return strings.TrimRight(allPaths, "\n")
}

func readBaseProfile() string {
	content, err := os.ReadFile("default.sb")
	handleFileReadError(err)
	return string(content)
}

func handleFileReadError(err error) {
	if err != nil {
		logErr("Something went wrong while reading the base profile", err)
	}
}
